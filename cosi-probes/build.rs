use cargo_bpf_lib::bindgen as bpf_bindgen;
use std::env;
use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command;

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    generate_bindings(&out_dir);
}

fn generate_bindings(out_dir: &Path) {
    let path = out_dir.join("bindings.rs");

    rerun_if_changed("include");

    let mut builder = bpf_bindgen::builder();

    let name = "bindings";

    builder = builder.header("include/bindings.h");

    let mut bindings = builder
        .generate_inline_functions(true)
        .generate()
        .expect("failed to generate bindings")
        .to_string();

    bindings.push_str("use redbpf_probes::helpers::bpf_probe_read;");

    let mut file = File::create(&path).unwrap();

    writeln!(
        &mut file,
        r"
/// Auto generated by BPF bindgen.
mod {name} {{
#![allow(warnings, unused)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(non_snake_case)]
#![allow(unused_unsafe)]
#![allow(clippy::all)]
{bindings}
}}
pub use {name}::*;
",
        name = name,
        bindings = bindings
    )
    .unwrap();

    let _ = Command::new("rustfmt")
        .arg("--edition=2018")
        .arg("--emit=files")
        .arg(&path)
        .status();
}

fn rerun_if_changed(path: &str) {
    println!("cargo:rerun-if-changed={}", path)
}
